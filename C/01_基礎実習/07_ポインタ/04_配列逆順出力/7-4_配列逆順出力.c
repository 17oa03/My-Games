/*
【プログラム概要】
標準入力より整数を5個入力し、
入力順とは逆に標準出力に出力する。
*/

/*【プログラム】*/
#include <stdio.h>

#define ELEMENT 5 /* マクロ定数の定義 */

int main(void)
{
	int array[ELEMENT]; /* 配列の定義 */

	int i; /* カウンタ変数の定義 */

	int *p_array; /* ポインタ変数の宣言 */

	p_array = array; /* 配列の先頭アドレスをセット(array = &array[0]) */

	for (i = 0; i < ELEMENT; i++) {

		printf("整数 ==> ");
		scanf("%d", p_array + i); /* 「ポイント変数 + カウンタ変数」でアドレスを進める */
	}

	printf("---逆順出力---\n");

	for (i--; i >= 0; i--) { /* カウンタ変数をデクリメントしながら逆順出力 */
		printf("%9d\n", *(p_array + i));
	}

	return 0;
}

/*
【実行結果】
整数 ==> 34
整数 ==> -5
整数 ==> 123
整数 ==> 0
整数 ==> -21
---逆順出力---
      -21
        0
      123
       -5
       34
*/

/*
【考察】
1回目のfor文のカウンタ変数の値は「5」になる、
なぜ、「4」にならないのか？

これは、
for文の実行順序が関係している、

--------------------------------------------
for (初期化式; 条件式; 再初期化式){ 処理; }
--------------------------------------------

for文の初期化式は、
1回目のループ前に実行される、
2回目のループ以降は、
再初期化式がループ前に実行される、
そして条件式がFalse(偽)になるまで繰り返す、
つまり...

for文の実行順序は、
初期化式(i = 0)   →条件式の評価(i(0) < ELEMENT(5))→処理→
再初期化式(i++(1))→条件式の評価(i(1) < ELEMENT(5))→処理→
再初期化式(i++(2))→条件式の評価(i(2) < ELEMENT(5))→処理→
再初期化式(i++(3))→条件式の評価(i(3) < ELEMENT(5))→処理→
再初期化式(i++(4))→条件式の評価(i(4) < ELEMENT(5))→処理→
再初期化式(i++(5))→条件式の評価(i(5) < ELEMENT(5))→ループを抜ける

これが、
カウンタ変数が「5」になる理由です。

2回目のfor文では、
初期化式にデクリメントを記述し、
確保しているメモリ領域外のアドレスにアクセスすることを
防いでいます。
*/