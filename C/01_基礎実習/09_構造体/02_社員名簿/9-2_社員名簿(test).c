/*
【プログラム概要】
社員名簿(5名分)の構造体配列を初期化し、
年齢の降順に出力する。
*/

/*【プログラム】*/
#include <stdio.h>

/* 記号定数の定義 */
#define EMPLOYEE 5 /* 社員の人数 */

/* 構造体の宣言 */
struct date {
	int y; /* 年 */
	int m; /* 月 */
	int d; /* 日 */
};

/* 構造体の宣言 */
struct employee {
	int    no;          /* 社員番号 */
	char   name[11];    /* 氏名 */
	struct date enploy; /* 入社年月日 */
	struct date birth;  /* 生年月日 */
};

int main(void)
{
	/* 構造体配列の定義と初期化 */
	struct employee data[EMPLOYEE] = {
		{ 1212, "sato",      { 2002,  4,  1 }, { 1982,  6, 23 } }, /* 1人目 */
		{ 2353, "suzuki",    { 2001,  4,  1 }, { 1984,  9, 30 } }, /* 2人目 */
		{ 3147, "takahashi", { 2001, 10,  1 }, { 1986, 10, 11 } }, /* 3人目 */
		{ 5206, "tanaka",    { 1995,  4, 20 }, { 1986, 10, 10 } }, /* 4人目 */
		{ 6447, "watanabe",  { 1988,  3, 25 }, { 1985,  4, 20 } }, /* 5人目 */
	};

	/* データ交換の際に必要な構造体変数 */
	struct employee tmp_data;

	/* カウンタ変数 */
	int i, j;

	/* 生年月日を8桁の整数で比較する為の配列と変数 */
	int ymd[EMPLOYEE];
	int tmp;

	/* 生年月日を8桁の整数に変換してint型配列に代入 */
	for (i = 0; i < EMPLOYEE; i++) {
		ymd[i] = ymd[i] + (data[i].birth.y * 10000);
		ymd[i] = ymd[i] + (data[i].birth.m * 100);
		ymd[i] = ymd[i] + (data[i].birth.d);
	}

	/* 年齢の降順にソートする */
	for (i = 0; i < EMPLOYEE - 1; i++) {
		for (j = i + 1; j < EMPLOYEE; j++) {

			/* 8桁の生年月日を比較 */
			if (ymd[i] > ymd[j]) {

				/* 構造体配列のデータ交換 */
				tmp_data = data[i];
				data[i]  = data[j];
				data[j]  = tmp_data;

				/* 8桁の生年月日のデータ交換 */
				tmp    = ymd[i];
				ymd[i] = ymd[j];
				ymd[j] = tmp;
			}
		}
	}

	/* 出力 */
	printf("社員番号 氏    名   入社年月日  生年月日 \n");
	printf("-------- ---------- ---------- ----------\n");

	for (i = 0; i < EMPLOYEE; i++) {

		printf("%8d ",  data[i].no);
		printf("%-11s", data[i].name); /* 左詰めには変換指定子の間に「-(ハイフン)」を使う */

		printf("%4d/%2d/%2d ", 
			data[i].enploy.y, 
			data[i].enploy.m, 
			data[i].enploy.d); /* メンバ変数の参照には「.(ドット)」演算子を使う */

		printf("%4d/%2d/%2d\n", 
			data[i].birth.y, 
			data[i].birth.m, 
			data[i].birth.d); /* メンバ変数が構造体変数でもドット演算子で参照できる */
	}

	return 0;
}

/*
【実行結果】
社員番号 氏    名   入社年月日   生年月日
-------- ---------- ---------- ----------
    1212 sato       2002/ 4/ 1 1982/ 6/23
    2353 suzuki     2001/ 4/ 1 1984/ 9/30
    6447 watanabe   1988/ 3/25 1985/ 4/20
    5206 tanaka     1995/ 4/20 1986/10/10
    3147 takahashi  2001/10/ 1 1986/10/11
*/

/*
【考察】
構造体はネストすることができる、
構造体のメンバとして、
別の構造体を宣言できるということ。

構造体配列の初期化は、

【例1】
構造体変数[要素数] = {
	{ 値, 値, 値, },
	{ 値, 値, 値, },
	{ 値, 値, 値, },
};

文字列は「"(ダブルコーテーション)」で囲み、
メンバ変数が構造体変数の場合は、
さらに「{}」を書くと初期化ができる。

【例2】
構造体変数[要素数] = {
	{ 値, { 値, "文字列", 値 }, 値, },
	{ 値, { 値, "文字列", 値 }, 値, },
	{ 値, { 値, "文字列", 値 }, 値, },
};

ソートに関しては、
for文の2重ループで、
添字[0]から他の要素を比較しながら
データ交換を行っている。

------------------------------
添字[0]と添字[1,2,3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[1]と添字[2,3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[2]と添字[3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[3]と添字[4]を比較、
自分が相手よりも大きい場合、
データ交換をする。
------------------------------

以上がソートの動きになる、
外側ループの継続条件に注意、
ループの回数を「-1」しないと
領域外を参照して処理を行ってしまう。
*/