/*
【プログラム概要】
社員名簿(5名分)の構造体配列を初期化し、
年齢の降順に出力する。
*/

/*【プログラム】*/
#include <stdio.h>

#define EMPLOYEE 5 /* 社員の人数 */

struct date { /* 構造体の宣言 */
	int y; /* 年 */
	int m; /* 月 */
	int d; /* 日 */
};

struct employee { /* 構造体の宣言 */
	int    no;          /* 社員番号 */
	char   name[11];    /* 氏名 */
	struct date enploy; /* 入社年月日 */
	struct date birth;  /* 生年月日 */
};

int main(void)
{
	struct employee data[EMPLOYEE] = { /* 構造体配列の定義と初期化 */
		{ 1212, "sato",      { 2002,  4,  1 }, { 1982,  6, 23 } }, /* 1人目 */
		{ 2353, "suzuki",    { 2001,  4,  1 }, { 1984,  9, 30 } }, /* 2人目 */
		{ 3147, "takahashi", { 2001, 10,  1 }, { 1986, 10, 11 } }, /* 3人目 */
		{ 5206, "tanaka",    { 1995,  4, 20 }, { 1986, 10, 10 } }, /* 4人目 */
		{ 6447, "watanabe",  { 1988,  3, 25 }, { 1985,  4, 20 } }, /* 5人目 */
	};

	struct employee tmp_data; /* データ交換の際に必要な構造体変数 */

	int i, j; /* カウンタ変数 */

	int ymd[EMPLOYEE]; /* 生年月日を8桁の整数で比較する為の配列と変数 */

	int tmp; /* データ交換の際に必要な変数 */

	for (i = 0; i < EMPLOYEE; i++) { /* 生年月日を8桁の整数に変換して代入 */
		ymd[i] = ymd[i] + (data[i].birth.y * 10000);
		ymd[i] = ymd[i] + (data[i].birth.m * 100);
		ymd[i] = ymd[i] + (data[i].birth.d);
	}

	for (i = 0; i < EMPLOYEE - 1; i++) { /* 降順ソート */
		for (j = i + 1; j < EMPLOYEE; j++) {

			if (ymd[i] > ymd[j]) { /* 8桁の生年月日を比較 */

				tmp_data = data[i]; /* 構造体配列のデータ交換 */
				data[i]  = data[j];
				data[j]  = tmp_data;

				tmp    = ymd[i]; /* 8桁の生年月日のデータ交換 */
				ymd[i] = ymd[j];
				ymd[j] = tmp;
			}
		}
	}

	printf("社員番号 氏    名   入社年月日  生年月日 \n"); /* 出力 */
	printf("-------- ---------- ---------- ----------\n");

	for (i = 0; i < EMPLOYEE; i++) {

		printf("%8d ",  data[i].no);
		printf("%-11s", data[i].name); /* 左詰めには変換指定子の間に「-(ハイフン)」を使う */

		printf("%4d/%2d/%2d ", 
			data[i].enploy.y, 
			data[i].enploy.m, 
			data[i].enploy.d); /* メンバ変数の参照には「.(ドット)」演算子を使う */

		printf("%4d/%2d/%2d\n", 
			data[i].birth.y, 
			data[i].birth.m, 
			data[i].birth.d); /* メンバ変数が構造体変数でもドット演算子で参照できる */
	}

	return 0;
}

/*
【実行結果】
社員番号 氏    名   入社年月日   生年月日
-------- ---------- ---------- ----------
    1212 sato       2002/ 4/ 1 1982/ 6/23
    2353 suzuki     2001/ 4/ 1 1984/ 9/30
    6447 watanabe   1988/ 3/25 1985/ 4/20
    5206 tanaka     1995/ 4/20 1986/10/10
    3147 takahashi  2001/10/ 1 1986/10/11
*/

/*
【考察】
構造体はネストすることができる、
構造体のメンバとして、
別の構造体を宣言できる。

構造体配列の初期化は、

【例1】
構造体変数[要素数] = {
	{ 値, 値, 値, },
	{ 値, 値, 値, },
	{ 値, 値, 値, },
};

文字列は「"(ダブルコーテーション)」で囲み、
メンバ変数が構造体変数の場合は、
さらに「{}」を書くと初期化ができる。

【例2】
構造体変数[要素数] = {
	{ 値, { 値, "文字列", 値 }, 値, },
	{ 値, { 値, "文字列", 値 }, 値, },
	{ 値, { 値, "文字列", 値 }, 値, },
};

降順ソートに関しては、
for文の2重ループで、
添字[0]から他の要素を比較しながら
データ交換を行っている。

------------------------------
添字[0]と添字[1,2,3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[1]と添字[2,3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[2]と添字[3,4]を比較、
自分が相手よりも大きい場合、
データ交換をする。

添字[3]と添字[4]を比較、
自分が相手よりも大きい場合、
データ交換をする。
------------------------------

以上が降順ソートの動きになる、
外側ループの継続条件に注意、
ループの回数を「-1」しないと
領域外を参照して処理を行ってしまう。
*/