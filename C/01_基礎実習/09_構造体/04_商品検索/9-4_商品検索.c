/*
【プログラム概要】
商品コードを標準入力より入力し、
該当する商品の商品名、
単価を検索して標準出力へ出力する。
99が入力された場合はプログラム終了、
結果出力には構造体のポインタ変数を使用する。
*/

/*【プログラム】*/
#include <stdio.h>

#define ITEMS 5 /* 商品数 */

struct product { /* 構造体の宣言 */
	int  no;       /* 商品コード */
	char name[11]; /* 商品名 */
	int  price;    /* 金額 */
};

int main(void)
{
	struct product data[] = { /* 構造体配列の定義と初期化 */
		{ 21, "鉛筆",      30 },
		{ 68, "ノート",   100 },
		{ 37, "定規",     150 },
		{ 40, "消しゴム",  50 },
		{ 85, "コンパス", 230 },
	};

	struct product *p_data; /* 構造体のポインタ変数の宣言 */

	int code = 0; /* 商品コードの入力値 */

	while (code != 99) { /* 終了コードが入力されるまで処理を繰り返す */

		printf("商品コード ==> ");
		scanf("%d", &code); /* 入力 */

		if (code != 99) {

			for (p_data = data; p_data < data + ITEMS && code != p_data->no; p_data++); /* 一致探索 */

			if (p_data < data + ITEMS) { /* 該当する商品がある場合 */

				printf("商品名  :  %s\n", p_data->name);
				printf("単  価  :  %d\n", p_data->price);
			}
			else /* それ以外の場合 */
			{

				printf("該当する商品はありません。\n");
			}
		}
	}

	return 0;
}

/*
【実行結果1】
商品コード ==> 37
商品名  :  定規
単  価  :  150
商品コード ==> 12
該当する商品はありません。
商品コード ==> 85
商品名  :  コンパス
単  価  :  230
商品コード ==> 99

【実行結果2】
商品コード ==> 99

【実行結果3】
商品コード ==> 21
商品名  :  鉛筆
単  価  :  30
商品コード ==> 68
商品名  :  ノート
単  価  :  100
商品コード ==> 37
商品名  :  定規
単  価  :  150
商品コード ==> 40
商品名  :  消しゴム
単  価  :  50
商品コード ==> 85
商品名  :  コンパス
単  価  :  230
商品コード ==> 99
*/

/*
【考察】
構造体のポインタ変数を宣言、
for文でアドレスをセット、
条件文に「p_data < data + ITEMS(商品の数)」で
「ITEMS」先のアドレスを指定しているので、
ポインタ変数のアドレスがインクリメントされて
比較しているアドレスに到達するまでループされる。

構造体のポインタ変数から
メンバ変数の参照をするには、
「->(アロー)」演算子を使う。
*/